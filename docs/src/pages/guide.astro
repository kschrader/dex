---
import Base from '../layouts/Base.astro';
import Terminal from '../components/Terminal.astro';
---

<Base title="Guide" description="How to use dex with Claude Code for persistent task management">
  <h1>Guide</h1>

  <p>Dex helps Claude Code act as a <strong>master coordinator</strong> for complex work—breaking down tasks, tracking progress, and preserving context across sessions.</p>

  <h2>The Core Idea</h2>

  <p>When you tell Claude "use dex" or invoke <code>/dex</code>, you're asking it to create <strong>persistent tickets</strong> that survive beyond the current session. Unlike Claude's built-in task tracking (which disappears when the session ends), dex tasks are stored as files in your repository.</p>

  <p>This means:</p>
  <ul>
    <li>You can close Claude Code and pick up exactly where you left off</li>
    <li>Context, decisions, and progress are preserved</li>
    <li>Multiple sessions (or agents) can coordinate on the same work</li>
    <li>Task history lives alongside your code in git</li>
  </ul>

  <h2>When to Use Dex</h2>

  <p><strong>Use dex when:</strong></p>
  <ul>
    <li>Work spans multiple sessions or days</li>
    <li>You need to break down a complex feature into steps</li>
    <li>You want to preserve decisions and context for later</li>
    <li>Work might be handed off or revisited</li>
  </ul>

  <p><strong>Skip dex when:</strong></p>
  <ul>
    <li>It's a quick, single-session task</li>
    <li>No context needs to be preserved</li>
    <li>The overhead isn't worth it</li>
  </ul>

  <h2>dex vs Claude Code's TaskCreate</h2>

  <p>Claude Code has built-in task tools (<code>TaskCreate</code>, <code>TaskUpdate</code>, <code>TaskList</code>). These are <strong>not</strong> the same as dex.</p>

  <table>
    <thead>
      <tr>
        <th></th>
        <th>dex</th>
        <th>Claude Code TaskCreate</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Persistence</strong></td>
        <td>Persists in <code>.dex/</code> files</td>
        <td>Session-only, lost when session ends</td>
      </tr>
      <tr>
        <td><strong>Context</strong></td>
        <td>Rich (description + context + result)</td>
        <td>Basic (subject + description)</td>
      </tr>
      <tr>
        <td><strong>Hierarchy</strong></td>
        <td>3-level (epic → task → subtask)</td>
        <td>Flat dependencies only</td>
      </tr>
      <tr>
        <td><strong>Collaboration</strong></td>
        <td>Git-trackable, shareable</td>
        <td>Not shareable</td>
      </tr>
    </tbody>
  </table>

  <p><strong>Rule of thumb:</strong> Use dex for work that needs to persist, be handed off, or tracked across sessions. Use Claude Code's TaskCreate only for ephemeral in-session tracking (like a scratchpad).</p>

  <h2>Basic Workflow</h2>

  <h3>Starting Work</h3>

  <p>Tell Claude what you want to accomplish and ask it to track with dex:</p>

  <Terminal>
    <pre class="cli-output"><span class="cli-dim">&gt;</span> Add JWT authentication to the API. Use dex to track the work.</pre>
  </Terminal>

  <p>Claude will create a task with rich context—not just "add auth" but the full requirements, approach, and acceptance criteria. Under the hood, it runs something like:</p>

  <Terminal>
    <pre class="cli-output"><span class="cli-dim">$</span> dex create -d "Add JWT authentication" --context "Implement JWT-based
auth for the API. Need: token generation on login, verification
middleware for protected routes, refresh token flow. Use jsonwebtoken
library. Protect /api/users/* and /api/admin/* routes..."</pre>
  </Terminal>

  <p>For larger work, Claude breaks it into subtasks automatically:</p>

  <Terminal>
    <pre class="cli-output"><span class="cli-dim">$</span> dex create -d "Create auth middleware" --parent abc123 --context "..."
<span class="cli-dim">$</span> dex create -d "Add login endpoint" --parent abc123 --context "..."
<span class="cli-dim">$</span> dex create -d "Add token refresh flow" --parent abc123 --context "..."</pre>
  </Terminal>

  <h3>Resuming Work</h3>

  <p>In a new session, ask Claude to continue:</p>

  <Terminal>
    <pre class="cli-output"><span class="cli-dim">&gt;</span> Continue working on the auth implementation.</pre>
  </Terminal>

  <p>Claude checks what's pending and reads the context:</p>

  <Terminal>
    <pre class="cli-output"><span class="cli-dim">$</span> dex list
<span class="cli-yellow">[ ]</span> <span class="cli-bold">abc123</span>: Add JWT authentication
<span class="cli-dim">    ├──</span> <span class="cli-green">[x]</span> <span class="cli-bold">def456</span>: Create auth middleware
<span class="cli-dim">    ├──</span> <span class="cli-yellow">[ ]</span> <span class="cli-bold">ghi789</span>: Add login endpoint
<span class="cli-dim">    └──</span> <span class="cli-yellow">[ ]</span> <span class="cli-bold">jkl012</span>: Add token refresh flow

<span class="cli-dim">$</span> dex show ghi789
<span class="cli-yellow">[ ]</span> <span class="cli-bold">ghi789</span>: Add login endpoint

<span class="cli-bold">Context:</span>
  POST /api/auth/login endpoint. Accept email/password, verify
  against database, return JWT token pair (access + refresh).
  Use bcrypt for password verification. Return 401 for invalid
  credentials with generic error message...</pre>
  </Terminal>

  <p>The context tells Claude exactly what to do without you re-explaining.</p>

  <h3>Completing Work</h3>

  <p>When Claude finishes a task, it records what was done:</p>

  <Terminal>
    <pre class="cli-output"><span class="cli-dim">$</span> dex complete ghi789 -r "Added POST /api/auth/login endpoint.
Verifies credentials with bcrypt, returns JWT access token (15m)
and refresh token (7d). Tested with valid/invalid credentials.
All 24 tests passing."</pre>
  </Terminal>

  <p>This result becomes part of the permanent record—useful for understanding what happened later.</p>

  <h3>From Plans to Tasks</h3>

  <p>After using Claude's plan mode, convert the plan to tracked tasks:</p>

  <Terminal>
    <pre class="cli-output"><span class="cli-dim">&gt;</span> /dex-plan</pre>
  </Terminal>

  <p>Claude reads the plan file and creates tasks with appropriate breakdown—simple plans become single tasks, complex plans become hierarchies with subtasks.</p>

  <h2>What Good Looks Like</h2>

  <h3>Good Task Context</h3>

  <p>Context should contain everything needed to do the work without asking questions:</p>

  <ul>
    <li><strong>What</strong> needs to be done (specific, not vague)</li>
    <li><strong>Why</strong> it's needed (background, motivation)</li>
    <li><strong>How</strong> to approach it (files to modify, patterns to follow)</li>
    <li><strong>Done when</strong> (acceptance criteria)</li>
  </ul>

  <p class="example-label">Good:</p>
  <blockquote>
    "Add rate limiting to /api/auth endpoints. Use express-rate-limit, 5 requests per minute per IP for /login, 20/min for /refresh. Return 429 with Retry-After header. Add to src/middleware/rate-limit.ts, apply in src/routes/auth.ts."
  </blockquote>

  <p class="example-label">Bad:</p>
  <blockquote>
    "Add rate limiting"
  </blockquote>

  <h3>Good Task Results</h3>

  <p>Results should capture what was actually done, not just "done":</p>

  <ul>
    <li><strong>What changed</strong> (implementation summary)</li>
    <li><strong>Key decisions</strong> (and why)</li>
    <li><strong>Verification</strong> (tests passing, manual testing done)</li>
  </ul>

  <p class="example-label">Good:</p>
  <blockquote>
    "Added rate limiting with express-rate-limit. Login: 5/min, refresh: 20/min. Configured per-IP tracking with custom key generator for proxy support. Returns 429 with Retry-After header. Added 6 tests for rate limit scenarios. All 30 tests passing."
  </blockquote>

  <p class="example-label">Bad:</p>
  <blockquote>
    "Added rate limiting"
  </blockquote>

  <h3>Verification is Critical</h3>

  <p><strong>Before marking any task complete, Claude must verify the work.</strong> Verification separates "I think it's done" from "it's actually done."</p>

  <p>Strong verification includes:</p>
  <ul>
    <li><strong>Test results</strong>: "All 60 tests passing" (with actual count)</li>
    <li><strong>Build status</strong>: "Build successful"</li>
    <li><strong>Manual testing</strong>: "Tested with valid/invalid inputs, both cases work"</li>
  </ul>

  <p>Weak verification to avoid:</p>
  <ul>
    <li>"Should work now" — "should" means not verified</li>
    <li>"Made the changes" — no evidence it works</li>
    <li>"Added tests" — did the tests pass?</li>
  </ul>

  <p>Good results always include explicit evidence: test counts, build output, manual testing outcomes.</p>

  <h2>Task Hierarchy</h2>

  <p>Dex supports three levels for organizing work:</p>

  <table>
    <thead>
      <tr>
        <th>Level</th>
        <th>Use For</th>
        <th>Example</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><strong>Epic</strong></td>
        <td>Large initiatives (5+ tasks)</td>
        <td>"Add user authentication system"</td>
      </tr>
      <tr>
        <td><strong>Task</strong></td>
        <td>Significant work items</td>
        <td>"Implement JWT middleware"</td>
      </tr>
      <tr>
        <td><strong>Subtask</strong></td>
        <td>Atomic steps</td>
        <td>"Add token verification function"</td>
      </tr>
    </tbody>
  </table>

  <p>Most work is a single task or a task with subtasks. Epics are for larger initiatives spanning multiple sessions.</p>

  <h2>Dependencies</h2>

  <p>Some tasks must be done in order. Tell Claude about dependencies:</p>

  <Terminal>
    <pre class="cli-output"><span class="cli-dim">&gt;</span> The deployment task should be blocked by the testing task.</pre>
  </Terminal>

  <p>Claude uses <code>--blocked-by</code> to create the dependency. Blocked tasks show an indicator in the list:</p>

  <Terminal>
    <pre class="cli-output"><span class="cli-yellow">[ ]</span> <span class="cli-bold">abc123</span>: Run integration tests
<span class="cli-yellow">[ ]</span> <span class="cli-bold">def456</span> <span class="cli-red">[B: abc123]</span>: Deploy to production</pre>
  </Terminal>

  <h2>Syncing with GitHub</h2>

  <p>Local dex tasks are ephemeral—working notes that evolve and get deleted as you go. When you sync to GitHub Issues, you create a <strong>permanent record</strong> of the work: what was planned, how it was broken down, and what was actually done.</p>

  <h3>Why Sync?</h3>

  <p><strong>For permanent records:</strong></p>
  <ul>
    <li>Local tasks get deleted as work evolves; GitHub Issues persist indefinitely</li>
    <li>Context, decisions, and results are preserved in a searchable history</li>
    <li>Commit metadata embeds in closed issues, tying work to actual code</li>
  </ul>

  <p><strong>For large or long-running work:</strong></p>
  <ul>
    <li>GitHub Issues survive repo clones, machine changes, and team transitions</li>
    <li>Use GitHub's project boards and milestones for higher-level organization</li>
  </ul>

  <p><strong>For team visibility:</strong></p>
  <ul>
    <li>Team members see progress without using Claude Code</li>
    <li>GitHub notifications keep everyone informed</li>
  </ul>

  <h3>Task IDs vs Issue Numbers</h3>

  <p>Dex task IDs (<code>abc123</code>) are ephemeral—they change, get deleted, and become meaningless. <strong>Never put task IDs in commits, PRs, or documentation.</strong></p>

  <p>GitHub issue numbers (<code>#42</code>) are permanent. Once synced, reference the issue number in your commits and PRs, not the dex task ID.</p>

  <h3>Enabling Sync</h3>

  <p>Configure your repository in <a href="/config#github-sync">config</a>. Dex authenticates via the <code>gh</code> CLI or <code>GITHUB_TOKEN</code> environment variable.</p>

  <p>By default, tasks sync automatically whenever you create, update, or complete a task. You can disable this to sync only manually or periodically—see <a href="/config#github-sync">auto-sync settings</a>.</p>

  <h3>What Gets Synced</h3>

  <p>When you sync a task:</p>
  <ul>
    <li>Task description → issue title</li>
    <li>Task context → issue body</li>
    <li>Subtasks → expandable checklists with context and results</li>
    <li>Completion result → comment when the issue closes</li>
    <li>Commit metadata (SHA, branch, URL) → embedded in closed tasks</li>
  </ul>

  <h3>Manual Sync</h3>

  <p>Push local tasks to GitHub Issues:</p>

  <Terminal>
    <pre class="cli-output"><span class="cli-dim">$</span> dex sync
Syncing 3 task(s) to owner/repo...
<span class="cli-dim">[1/3]</span> <span class="cli-green">+</span> abc123: Add JWT authentication
<span class="cli-dim">[2/3]</span> <span class="cli-yellow">↻</span> def456: Fix login redirect
<span class="cli-dim">[3/3]</span> <span class="cli-dim">∙</span> ghi789: Add rate limiting
Synced 3 task(s) to owner/repo
  <span class="cli-dim">(1 created, 1 updated, 1 unchanged)</span></pre>
  </Terminal>

  <p>Use <code>--dry-run</code> to preview what would sync without making changes.</p>

  <h3>Importing from GitHub</h3>

  <p>Pull GitHub Issues into local tasks:</p>

  <Terminal>
    <pre class="cli-output"><span class="cli-dim">$</span> dex import #42
Imported issue #42 as task xyz789: "Add password reset flow"
  <span class="cli-dim">Created 3 subtask(s)</span></pre>
  </Terminal>

  <p>Use <code>--all</code> to import all open issues at once.</p>

  <h3>Sync-on-Push</h3>

  <p>Issues only close when their completion commits reach the remote. This creates a reliable record: a closed GitHub Issue means the work is <strong>actually shipped</strong>, not just marked done locally.</p>

  <p class="example-label">Why this matters:</p>
  <blockquote>
    You complete a task locally, but your branch isn't merged yet. Without sync-on-push, the issue would close immediately—a "closed" issue with no shipped code. With sync-on-push, the GitHub record accurately reflects reality: the issue closes only when your work is actually in the repository.
  </blockquote>

  <Terminal>
    <pre class="cli-output"><span class="cli-dim">$</span> dex complete abc123 -r "Added JWT middleware. All tests passing."
<span class="cli-green">[x]</span> abc123: Add JWT authentication

<span class="cli-dim">$</span> dex sync
<span class="cli-dim">[1/1]</span> <span class="cli-yellow">↻</span> abc123: Add JWT authentication
Synced 1 task(s) <span class="cli-dim">(issue stays open until pushed)</span>

<span class="cli-dim">$</span> git push && dex sync
<span class="cli-dim">[1/1]</span> <span class="cli-yellow">↻</span> abc123: Add JWT authentication
Synced 1 task(s) <span class="cli-dim">(issue now closed)</span></pre>
  </Terminal>

  <p><strong>Note:</strong> If <code>.dex/</code> is in your <code>.gitignore</code>, sync-on-push detection is disabled since dex can't determine push status.</p>

  <h2>Behavior Notes</h2>

  <p>A few behaviors to be aware of:</p>

  <ul>
    <li><strong>Subtasks must complete first</strong>: A task with pending subtasks cannot be completed. Complete all children before the parent.</li>
    <li><strong>Blockers are soft enforcement</strong>: Blocked tasks <em>can</em> be completed, but Claude will see a warning. This allows flexibility while communicating intended order.</li>
    <li><strong>Delete cascades to children</strong>: Deleting a parent task also deletes all its subtasks.</li>
    <li><strong>Maximum depth is 3 levels</strong>: Epic → Task → Subtask. Attempting to create a child of a subtask will fail.</li>
  </ul>

  <h2>Tips for Working with Claude</h2>

  <ul>
    <li><strong>"Use dex"</strong> — Tells Claude to track work persistently</li>
    <li><strong>"What's next?"</strong> — Claude checks pending tasks and continues</li>
    <li><strong>"Break this down"</strong> — Claude creates subtasks for complex work</li>
    <li><strong>"Mark that complete"</strong> — Claude records the result</li>
    <li><strong>"/dex-plan"</strong> — Converts a plan file to tracked tasks</li>
  </ul>

  <p>You don't need to know the CLI commands—Claude handles that. Focus on describing what you want to accomplish.</p>
</Base>

<style>
  .cli-output {
    font-family: var(--font-mono);
    font-size: 0.875rem;
    line-height: 1.6;
    color: #e5e5e5;
    margin: 0;
    white-space: pre-wrap;
    word-break: break-word;
  }

  .cli-dim {
    color: #737373;
  }

  .cli-green {
    color: #4ade80;
  }

  .cli-yellow {
    color: #facc15;
  }

  .cli-red {
    color: #f87171;
  }

  .cli-bold {
    font-weight: 600;
    color: #fff;
  }

  .example-label {
    font-weight: 600;
    margin-bottom: 0.25rem;
    color: var(--text-secondary);
  }

  blockquote {
    margin: 0 0 1.5rem 0;
    padding: 0.75rem 1rem;
    background: var(--surface);
    border-left: 3px solid var(--border);
    border-radius: 0 4px 4px 0;
    font-size: 0.9rem;
    color: var(--text-secondary);
  }
</style>
